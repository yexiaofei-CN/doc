## 类原理

- ArrayList&&LinkedList
```text
ArrayList：
     1)底层采取的是队列的原理
	 2)每个元素都有自己的索引号
	 3)重复的元素可以添加，因为重复的元素可以出现在不同的位置
	*4)查询效率高
LinkdList：
     1)底层采取的是链表结构
	 2)每个元素都有自己的索引号
	 3)重复的元素可以添加，因为重复的元素可以出现在不同的位置
	*4)插入，修改，删除效率提高
	
看到这就会想到为什么ArrayList查询效率高呢？相反LinkdList插入，修改删除效率高呢？
在刚开始学习的时候我也有疑惑，当然也是初学java队列与链表的知识不是太清楚。

队列：就好比在火车站买票一样，先进先出，紧紧排在一起。
链表：链表不是连续的，是你加进去一个，我给你个内存。那么怎么找呢？链表的每一个元素实际是这么组成的。
      头信息+实际数据+尾部信息。
	  头信息:保留上一个链表元素的信息地址。 尾部信息：保留下一个元素的信息。中间的才是实际保留的内容。
	  
了解了队列与链表后，大概就知道ArrayList查询效率高，LinkdList插入，修改，删除效率高。

数组有个缺点：数组声明大小后，不可改变。数组在内存中存在一个个的地址。而Arraylist可以理解为可以增长长度的数组。

查询：
	当你实例化ArrayList这个类的时候，实际上向内存中申请了一块地址。告诉内存我需要保存一些数据。内存就会给你分配一
	空间。而数组的话需要一系列的地址。你不告诉我你需要多大的地方我怎么给你留？所以初始化的时候你需要声明数组的长度。
	这样数组的地址固定了。你需要找它就变得方便了。比如：定义一个长度100的数组你需要查找第50个，你只需要找到他第50个
	地址，就可以把他找到。
	刚才说了链表的结构是：头部信息+实际数据+尾部信息。 每个元素与每个元素之间是关联的。就想锁链一样。
	举例： 这个元素保留的上一个元素的信息地址 和保留的下一个元素的信息。只有找到第一个元素才能找到它的下一个元素。
	       比如要找到数组中的第50个元素，就必须从第1个元素开始找。这样就降低了效率。所以数组的查询效率高。

删除:
    首先删除的话分为2个步骤:1、找到这个元素。2、删除元素。
	步骤1当然是数组查找的快。但是步骤2删除元素就是链表删除的快了。
	因为数组删除元素的话还是刚才的定义100个长度。我需要删除第50个元素。我先找到第50个元素。在删除第50个元素。但是删
	除第50个元素后，后面的元素就会往前靠拢，第51个元素就会成为第50个元素。如果定义数以万计的数组长度。那就大大降低了
	效率。
	而相对比链表查找的速度慢。但是链表是不连续的。如果要删除第50个元素。我只需要打断它的头信息和尾信息就可以。其他的
	元素是不变的。相对比链表的删除效率快。想想锁链就可以。你如果要敲碎其中的一环。你就需要敲到他与上一环连接的部分，
	还有它与下一环连接的部分。打碎上下环的连接再把 上下环接起来完成删除
	

插入，修改：
    懂了查询与删除的道理，插入，与修改的话就都明白了。
	注意就是链表是一一对应的。
	
还有一个就是ArrayList：
    当初始化这个类的时候，内存中就会开辟一块预设内存给它来存储数据。当你存储的数据达到它给定的内存时，它会在开辟一块
	比他大大约1.5倍的数组长度（是这样吗？）把旧的数组拷贝到新的数组中去，也就完成了数组的自增。
	ArrayList中其实就是一个数组。只不过是可变的集合了。比数组又强大了。
	
ArrayList 想想排队插队买票。 Linkedlist想想锁链。
都是大白话。	
```

- HashMap
- 参考文献 http://www.cnblogs.com/acm-bingzi/p/javaMap.html   http://blog.csdn.net/fujiakai/article/details/51585767
```text
HashMap:
    HashMap是无序得,是根据键得hashcode值存储数据，底层是哈希表，根据键获取它得值，具有很快得访问速度（哈希底层没看过呢）,
最多允许一条记录得键为null,允许多个键得值为null，HashMap不支持线程同步(任一时刻可以有有多个线程同时写HashMap)，可能会导致
数据不一致，同步得话可以调用Collections工具类中得synchonized方法使HashMap具有同步得能力或者ConcurrentHashMap    
```
- LinkedHashMap
- 参考文献 http://blog.csdn.net/ns_code/article/details/37867985
```text
    保存了记录得插入顺序，先插入得先遍历出来，遍历会比HashMap慢，底层实现是哈希和链表
    
```
- TreeMap
- 参考文献 http://blog.csdn.net/a616413086/article/details/52586006
```text
    默认是按升序排，也可以指定排序的比较器。遍历的时候按升序遍历  底层实现是红黑树
  
```
- HashTable
- 源码剖析：http://blog.csdn.net/ns_code/article/details/36191279 
```text
    底层实现也是哈希表，是线程安全得
```
- ConcurrentHashMap&
```text
    ConcurrentHashMap 锁的粒度变小了 HashTable锁的整个hash表,ConcurrentHashMap--锁桶,默认分为16个桶,可同时16个线程写入,读取不需要上锁。
    
```
- ConcurrentSkipListMap
- 参考文献   http://blog.csdn.net/sunxianghuang/article/details/52221913  http://www.educity.cn/java/498061.html
           
```text
   ConcurrentSkipListMap 跳帽 高并发且排序
```